        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Title</title>
            <script>
                //封装
                var name = "张学友";
                var age = 18;

                function sayHello(){
                    console.log("hello world");
                }

                var obj = {
                    name : "刘德华",
                    age : 50,
                    sayHello : function () {
                        //.....
                    }
                }

                var itcast = {
                    getEle:{

                    },

                }
                //继承
                //javaScript当中的继承是指
                //一个对象没有一些方法和属性，但是另外一个对象有
                //把另外一个对象的属性和方法，拿过来使用，就是继承

                var obj = {

                };

                var obj1 = {
                    name : "张学友",
                    sayHello: function () {
                        console.log("你好，我是张学友");
                    }
                }

        //        obj.sayHello();

                //混入式继承（mix-in）  for in

                for(var k in obj1){
                    //k可以获取到对象的每一个属性
                    //obj1[k]可以获取到对象的每一个属性的值
                    //这里使用k给对象新增属性的时候，不可以使用点语法
                    obj[k] = obj1[k];
                }

                obj.sayHello();

                //java
                //Class
                //Class Person(){
                //   string name;
                //   int age;
                //   public void sayHello(){
                //   }
                // }

                //Class Student:extend Person{
                //
                // }

        //        console.log(obj);

                //多态
                //多态是在强类型语言中比较常用，JavaScript中没有相应的体现
                //Animal  父类  父类的属性和方法供所有的子类共享 但是父类不能访问子类的属性和方法
                //Dog  子类
                //Cat  子类

                //Animal an = new Animal();
                //Dog dog = new Dog();

                //Animal an = new Dog();
                //使用父类的引用（指针）指向子类的对象 就叫做多态
                //使用多态来隐藏不同

//如何创建一个对象
  //1.对象字面量  {key:value,key:value...}
                //只能创建一次对象，复用性较差，如果要创建多个对象，代码冗余度太高
        //        var obj = {
        //            name:"演员",
        //            singer:"薛段子手",
        //            type:"流行"
        //        };
        //
        //        var obj1 ={
        //            name:"吻别",
        //            singer:"张学友",
        //            type:"流行"
        //        }
 //2.使用内置构造函数(创建函数里面定义对象)

        //        var obj = new Object();
        //
        //        obj.name = "一千个伤心的母牛";
        //        obj.singer = "张学友";
        //        obj.sing = function () {
        //            console.log("一千个伤心的母牛");
        //        }
        //
        //        var obj1 =new Object();
        //        obj.name = "一千个伤心的母牛";
        //        obj.singer = "张学友";
        //        obj.sing = function () {
        //            console.log("一千个伤心的母牛");
        //        }

 //3.封装简单的工厂函数 (不推荐使用了)
                function createSong(songName,singerName){
                    var o =new Object();
                    o.name = songName;
                    o.singer = singerName;

                    o.sing = function () {
                        console.log("让我来唱首歌");
                    }
                    return o;//{name:"",singer:"",sing:function...}
                }

                var obj = createSong("演员","薛之谦");

                var obj1 = createSong("一言难尽","张宇");
//4 自定义构造函数创建对象
        //构造函数名，首字母要大写！！！以示区分
        function Person() {
                    //默认隐含的操作，把刚才用new新创建出来的对象赋值给this
                    this.name = "尼古拉斯凯奇";
                    this.age = 50;
                    this.sayHello = function () {
                        console.log("Hey man");
                    }
                    //如果这里写其他的代码，会执行吗？  肯定会

                    return null;
                }

                var p = new Person();//new Object();
                console.log(p);
                p.sayHello();


                //构造函数的执行过程
                //1.使用new关键字创建对象
                //2.调用构造函数，把新创建出来的对象赋值给构造函数内的this
                //3.在构造函数内使用this为新创建出来的对象新增成员
                //4.默认返回新创建的这个对象 （普通的函数，如果不写返回语句，会返回undefined）


                //构造函数的返回值
                //1.如果不写返回值，默认返回的是新创建出来的对象 （一般都不会去写这个return语句）
                //2.如果我们自己写return语句 return的是空值（return;），或者是基本类型的值或者null，都会默认返回新创建出来的对象
                //3.如果返回的是object类型的值，将不会返回刚才新创建的对象，取而代之的是return后面的值

 //注意：如果像使用正常的函数一样使用构造函数
                //构造函数中的this将不再指向新创建出来的对象（因为根本就没有创建对象）
                //构造函数中的this这个时候指向的就是window全局对象
                //当使用this给对象添加成员的时候，全部都添加到了window上
        //        Animal("","",function () {
        //            console.log("我是函数");
        //        }); //这是一个错误的演示
        //
        //        window.bark();

        //如果在构造函数中定义函数，那么每次创建对象，都会重新创建该函数
        //但是函数内部代码完全相同，就造成了资源浪费
        //为了处理这个问题，我们要让所有的对象共用一个方法
        //在构造函数外部定义好该函数，将该函数赋值给构造函数内的方法

        //使用这种方式写好的方法中的this指向的就是调用该方法的对象
        //this 谁调用就是谁


        //使用这种方式存在的问题
        //1.全局变量增多，造成污染
        //2.代码结构混乱，不易维护



            </script>
        </head>
        <body>
            <h3>学习了对象的三大特性和创建对象的方式</h3>

        </body>
        </html>