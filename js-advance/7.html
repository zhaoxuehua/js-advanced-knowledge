<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        //递归
        //在函数内调用函数自己，就是递归
        //没有递归结束条件的递归，就是死递归

        //1.自己调用自己
        //2.要有结束的条件

        //使用递归的方法
        //化归思想：
        //化归思想，将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。
       
        function sum(n){
            if(n == 1)
            {
                return 1;
            }
            //return 1+2+3
            //return 1+2
            return sum(n-1) + n;
        }
        var num = sum(100);
        console.log(num);

//1、用递归处理阶乘问题
      //阶乘
        //n!
        //1*2*3...*n
        function factorial(n) {
            if(n == 1){
                return 1;
            }
            //return factorial(2) * 3  6
            //return factorial(1) * 2  2
            return factorial(n-1) * n;
        }
        console.log(factorial(5));

//2、用递归实现Fibonacc数列
     //斐波那契 数列
        //1 1 2 3 5 8 13 21
        //1 1
        //2 1
        //3 第1项 + 第2项
        //4 第2项 + 第3项
        //5 第3项 + 第4项

        //n (n-2)+(n-1)
        function fibonacci(n){
            if(n <= 2){
                return 1;
            }
            return fibonacci(n-1) + fibonacci(n-2);
        }
        console.log(fibonacci(10));

//3、使用递归遍历所有后代元素
         //给页面中所有的元素添加一个边框  1px solid pink
            //DOM中，没有提供直接获取后代元素的API
            //但是可以通过childNodes来获取所有的子节点

            //先找body的所有子元素
            //再找body的子元素的所有子元素

            var allChildren = []
function getChildNode(node){
    //先找子元素
    var nodeList = node.childNodes;
    //在用子元素再找子元素  这里就可以递归了
    //for循环中的条件，就充当了结束的条件
    for (var i = 0; i < nodeList.length; i++) {
        //childNode获取到到的节点包含了各种类型的节点
        //但是我们只需要元素节点  通过nodeType去判断当前的这个节点是不是元素节点
        var childNode = nodeList[i];
        //判断是否是元素节点
        if(childNode.nodeType == 1){
           // childNode.style.border = "1px solid pink";//也可以先不设置，放入数组，然后所有后代都找到后再设置所有的样式
            allChildren.push(childNode)
            getChildNode(childNode);//继续找nodelist[0]的后代，直到找完。  然后继续下一个nodelist[1]的后代
        }

    }
}
getChildNode(document.body);
//统一设置所有的样式
    for (var i = 0; i < allChildren.length; i++) {
                var child = allChildren[i];
                child.style.border= "1px solid pink";

            }
    </script>
</head>
<body>
<p>递归学习及案例
    <br>
    案例1：求阶乘<br>
    案例2：菲波那切数列<br>
    案例3：遍历所有后代元素
</p>
</body>
</html>